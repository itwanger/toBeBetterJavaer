分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。

> ❝
> 
> 实现分布式锁目前有三种流行方案，即基于数据库、Redis、ZooKeeper 的方案
> 
> ❞

**「方案一：」**

使用节点中的存储数据区域，ZK中节点存储数据的大小不能超过1M，但是只是存放一个标识是足够的，线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识

**「方案二：」**

使用子节点，每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序，默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可

![](https://cdn.jsdelivr.net/gh/itwanger/toBeBetterJavaer/images/zookeeper/fenbushisuo-1.png)


**「死锁风险:」**

两种方案其实都是可行的，但是使用锁的时候一定要去规避死锁

*   方案一看上去是没问题的，用的时候设置标识，用完清除标识，但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行

*   方案二也存在这个问题，但方案二可以利用ZK的临时顺序节点来解决这个问题，只要线程发生了异常导致程序中断，就会丢失与ZK的连接，ZK检测到该链接断开，就会自动删除该链接创建的临时节点，这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的

**「避免羊群效应」**

把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。

如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。

> ❝
> 
> 为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。
> 
> ❞

每次锁被释放，只会有一个锁请求者 会被通知到。

这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则。

![](https://cdn.jsdelivr.net/gh/itwanger/toBeBetterJavaer/images/zookeeper/fenbushisuo-2.png)


**「用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：」**

*   客户端连接 ZooKeeper，并`在/lock`下创建临时有序子节点，第一个客户端对应的子节点为`/lock/lock01/00000001`，第二个为 `/lock/lock01/00000002`；

*   其他客户端获取`/lock01`下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；

*   如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听`/lock01`的子节点变更消息，获得变更通知后重复此步骤直至获得锁；

*   完成业务流程后，删除对应的子节点，释放分布式锁；

在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。


整理：沉默王二，戳[转载链接](https://mp.weixin.qq.com/s/-evZg0epRrOr1IwQ3GJ2Zg)，作者：月伴飞鱼，戳[原文链接](https://mp.weixin.qq.com/s/B2ngp0q5kdWsCNH8sw_5DA)。