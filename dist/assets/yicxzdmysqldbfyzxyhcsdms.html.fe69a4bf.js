import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as n,a as e,d as t,b as r,e as c,r as l}from"./app.99eb8281.js";const o={},d={href:"https://mp.weixin.qq.com/s/e5Q4aJCX9xccTzBBGepx4g",target:"_blank",rel:"noopener noreferrer"},p=e("strong",null,"910 多名",-1),b={href:"https://mp.weixin.qq.com/s/e5Q4aJCX9xccTzBBGepx4g",target:"_blank",rel:"noopener noreferrer"},m=c(`<h2 id="一、问题复现" tabindex="-1"><a class="header-anchor" href="#一、问题复现" aria-hidden="true">#</a> 一、问题复现</h2><p>在实际的软件系统开发过程中，随着使用的用户群体越来越多，表数据也会随着时间的推移，单表的数据量会越来越大。</p><p>以订单表为例，假如每天的订单量在 4 万左右，那么一个月的订单量就是 120 多万，一年就是 1400 多万，随着年数的增加和单日下单量的增加，订单表的数据量会越来越庞大，<strong>订单数据的查询不会像最初那样简单快速，如果查询关键字段没有走索引，会直接影响到用户体验，甚至会影响到服务是否能正常运行</strong>！</p><p>下面我以某个电商系统的<strong>客户表</strong>为例，<strong>数据库是 Mysql，数据体量在 100 万以上，详细介绍分页查询下，不同阶段的查询效率情况</strong>（订单表的情况也是类似的，只不过它的数据体量比客户表更大）。</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-6a0fd06b-595b-4a70-b79c-008ec25f3ebb.jpg" alt="" loading="lazy"></p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-4c405350-b5c2-4a98-b919-1b01f2d97045.jpg" alt="" loading="lazy"></p><p>下面我们一起来测试一下，每次查询客户表时最多返回 100 条数据，不同的起始下，数据库查询性能的差异。</p><ul><li><strong>当起点位置在 0 的时候，仅耗时：18 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-23a24b41-14ca-4371-bdd6-b0ae7288d58d.jpg" alt="" loading="lazy"></p><ul><li><strong>当起点位置在 1000 的时候，仅耗时：23 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-21f287ff-0c00-47ad-8625-db80b9f89839.jpg" alt="" loading="lazy"></p><ul><li><strong>当起点位置在 10000 的时候，仅耗时：54 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-a2aae7d6-3def-4430-bd2a-23fcd2cbd02a.jpg" alt="" loading="lazy"></p><ul><li><strong>当起点位置在 100000 的时候，仅耗时：268 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-743791f9-6133-4203-ad67-40f22ff60032.jpg" alt="" loading="lazy"></p><ul><li><strong>当起点位置在 500000 的时候，仅耗时：1.16 s</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-7dc4ce81-5052-4cfc-822e-cfb00fee9de7.jpg" alt="" loading="lazy"></p><ul><li><strong>当起点位置在 1000000 的时候，仅耗时：2.35 s</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-2d5c5c66-c30d-4a4a-b025-0ca4d9d4fb76.jpg" alt="" loading="lazy"></p><p>可以非常清晰的看出，随着起点位置越大，分页查询效率成倍的下降，当起点位置在 1000000 以上的时候，对于百万级数据体量的单表，查询耗时基本上以秒为单位。</p><p>而事实上，<strong>一般查询耗时超过 1 秒的 SQL 都被称为慢 SQL</strong>，有的公司运维组要求的可能更加严格，比如小编我所在的公司，如果 SQL 的执行耗时超过 0.2s，也被称为慢 SQL，<strong>必须在限定的时间内尽快优化，不然可能会影响服务的正常运行和用户体验</strong>。</p><p>对于千万级的单表数据查询，小编我刚刚也使用了一下分页查询，<strong>起点位置在 10000000，也截图给大家看看，查询耗时结果：39 秒</strong>！</p><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-4d690fe6-78b4-44a5-979e-1e483ad62ac4.jpg" alt="" loading="lazy"></p><p>没有接触过这么大数据体量的同学，可能多少对这种查询结果会感到吃惊，事实上，这还只是数据库层面的耗时，还没有算后端服务的处理链路时间，以及返回给前端的数据渲染时间，以百万级的单表查询为例，如果数据库查询耗时 1 秒，再经过后端的数据封装处理，前端的数据渲染处理，以及网络传输时间，没有异常的情况下，差不多在 3～4 秒之间，可能有些同学对这个请求时长数值还不太敏感。</p><p>据互联网软件用户体验报告，当平均请求耗时在1秒之内，用户体验是最佳的，此时的软件也是用户留存度最高的；2 秒之内，还勉强过的去，用户能接受；当超过 3 秒，体验会稍差；超过 5 秒，基本上会卸载当前软件。</p><p>有的公司为了提升用户体验，会严格控制请求时长，当请求时长超过 3 秒，自动放弃请求，从而倒逼技术优化调整 SQL 语句查询逻辑，甚至调整后端整体架构，比如引入缓存中间件 redis，搜索引擎 elasticSearch 等等。</p><p>继续回到我们本文所需要探讨的问题，<strong>当单表数据量到达百万级的时候，查询效率急剧下降，如何优化提升呢</strong>？</p><h2 id="二、解决方案" tabindex="-1"><a class="header-anchor" href="#二、解决方案" aria-hidden="true">#</a> 二、解决方案</h2><blockquote><p>下面我们一起来看看具体的解决办法。</p></blockquote><h4 id="_2-1、方案一-查询的时候-只返回主键-id" tabindex="-1"><a class="header-anchor" href="#_2-1、方案一-查询的时候-只返回主键-id" aria-hidden="true">#</a> 2.1、方案一：查询的时候，只返回主键 ID</h4><p>我们继续回到上文给大家介绍的客户表查询，将<code>select *</code>改成<code>select id</code>，简化返回的字段，我们再来观察一下查询耗时。</p><ul><li><strong>当起点位置在 100000 的时候，仅耗时：73 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-0db3dbe4-8333-41d3-860e-00d5a9bdcb26.jpg" alt="" loading="lazy"></p><ul><li><strong>当起点位置在 500000 的时候，仅耗时：274 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-408e85b8-3ee6-4135-a470-baf01f7c41b0.jpg" alt="" loading="lazy"></p><ul><li><strong>当起点位置在 1000000 的时候，仅耗时：471 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-88755ad9-ec59-44ae-8f4b-8dcfb06abb7c.jpg" alt="" loading="lazy"></p><p>可以很清晰的看到，<strong>通过简化返回的字段，可以很显著的成倍提升查询效率</strong>。</p><p>实际的操作思路就是先通过分页查询满足条件的主键 ID，然后通过主键 ID 查询部分数据，可以显著提升查询效果。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-- 先分页查询满足条件的主键ID
select id from bizuser order by id limit 100000,10;

-- 再通过分页查询返回的ID，批量查询数据
select * from bizuser where id in (1,2,3,4,.....);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2、方案二-查询的时候-通过主键-id-过滤" tabindex="-1"><a class="header-anchor" href="#_2-2、方案二-查询的时候-通过主键-id-过滤" aria-hidden="true">#</a> 2.2、方案二：查询的时候，通过主键 ID 过滤</h4><p>这种方案有一个要求就是主键ID，<strong>必须是数字类型，实践的思路就是取上一次查询结果的 ID 最大值，作为过滤条件，而且排序字段必须是主键 ID，不然分页排序顺序会错乱</strong>。</p><ul><li><strong>查询 100000～1000100 区间段的数据，仅耗时：18 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-6442c1c1-65ac-4227-a68d-fb1f7e07210a.jpg" alt="" loading="lazy"></p><ul><li><strong>查询 500000～5000100 区间段的数据，仅耗时：18 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-458734b4-95b9-4a42-bcf6-cb0d6cf8bdf7.jpg" alt="" loading="lazy"></p><ul><li><strong>查询 1000000～1000100 区间段的数据，仅耗时：18 ms</strong></li></ul><p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-yicxzdmysqldbfyzxyhcsdms-150548d9-a12d-4207-91bc-2855b76c2152.jpg" alt="" loading="lazy"></p><p>可以很清晰的看到，带上主键 ID 作为过滤条件，查询性能非常的稳定，基本上在<code>20 ms</code>内可以返回。</p><p><strong>这种方案还是非常可行的，如果当前业务对排序要求不多，可以采用这种方案，性能也非常杠</strong>！</p><p><strong>但是如果当前业务对排序有要求，比如通过客户最后修改时间、客户最后下单时间、客户最后下单金额等字段来排序，那么上面介绍的【方案一】，比【方案二】查询效率更高</strong>！</p><h4 id="_2-3、方案三-采用-elasticsearch-作为搜索引擎" tabindex="-1"><a class="header-anchor" href="#_2-3、方案三-采用-elasticsearch-作为搜索引擎" aria-hidden="true">#</a> 2.3、方案三：采用 elasticSearch 作为搜索引擎</h4><p>当数据量越来越大的时候，尤其是出现分库分表的数据库，以上通过主键 ID 进行过滤查询，效果可能会不尽人意，例如订单数据的查询，<strong>这个时候比较好的解决办法就是将订单数据存储到 elasticSearch 中</strong>，通过 elasticSearch 实现快速分页和搜索，效果提升也是非常明显。</p><p>关于 elasticSearch 的玩法，以后有机会再给大家介绍。</p><h2 id="三、小结" tabindex="-1"><a class="header-anchor" href="#三、小结" aria-hidden="true">#</a> 三、小结</h2><p>不知道大家有没有发现，<strong>上文中介绍的表主键 ID 都是数值类型的，之所以采用数字类型作为主键，是因为数字类型的字段能很好的进行排序</strong>。</p><p>但如果当前表的主键 ID 是字符串类型，比如 uuid 这种，就没办法实现这种排序特性，而且搜索性能也非常差，因此不建议大家采用 uuid 作为主键ID，具体的数值类型主键 ID 的生成方案有很多种，比如自增、雪花算法等等，都能很好的满足我们的需求。</p><hr><p>没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟。</p>`,59),g={href:"https://mp.weixin.qq.com/s/9f_sOLiRwDS3pzC-mJ9jLQ",target:"_blank",rel:"noopener noreferrer"},h={href:"https://mp.weixin.qq.com/s/24rup4Jkch7ELdtI_l-yZg",target:"_blank",rel:"noopener noreferrer"},f={href:"https://mp.weixin.qq.com/s/zYLEUmbfmiKeFk03e1TxbA",target:"_blank",rel:"noopener noreferrer"},y={href:"https://mp.weixin.qq.com/s/6z06U97fmrkKB-J1umFTVQ",target:"_blank",rel:"noopener noreferrer"},x={href:"https://mp.weixin.qq.com/s/wfp8LBPPxHE_CM4d3wARQw",target:"_blank",rel:"noopener noreferrer"},u={href:"https://mp.weixin.qq.com/s/QYFB2NHhyZSBfdgSUcZU5g",target:"_blank",rel:"noopener noreferrer"},_={href:"https://mp.weixin.qq.com/s/SfEUk-4hE6ezUk2Lu6cd2g",target:"_blank",rel:"noopener noreferrer"},z={href:"https://mp.weixin.qq.com/s/CdIin5I7VvfaSk4z9J0FwQ",target:"_blank",rel:"noopener noreferrer"},v=e("p",null,[e("img",{src:"https://img-blog.csdnimg.cn/img_convert/61f1d83899ac533c2b892a3e39f09fdc.png",alt:"",loading:"lazy"})],-1);function j(q,w){const a=l("ExternalLinkIcon");return s(),n("div",null,[e("blockquote",null,[e("p",null,[e("a",d,[t("二哥的编程星球"),r(a)]),t("已经有 "),p,t(" 球友加入了，如果你也需要一个良好的学习氛围，"),e("a",b,[t("戳链接"),r(a)]),t("加入我们吧！这是一个Java学习指南+编程实战+LeetCode 刷题的私密圈子，你可以向二哥提问、帮你制定学习计划、和球友一起打卡成长，冲冲冲。")])]),m,e("ul",null,[e("li",null,[e("a",g,[t("先不管那么多，offer接了再说"),r(a)])]),e("li",null,[e("a",h,[t("假如我是核酸系统架构师"),r(a)])]),e("li",null,[e("a",f,[t("一套KTV管理系统，估价3万还是30万？"),r(a)])]),e("li",null,[e("a",y,[t("撸一个多线程永动任务"),r(a)])]),e("li",null,[e("a",x,[t("本次秋招最差面试体验给到华为！"),r(a)])]),e("li",null,[e("a",u,[t("给offer的公司不问技术细节？"),r(a)])]),e("li",null,[e("a",_,[t("入职一个月，就想跑路了？"),r(a)])]),e("li",null,[e("a",z,[t("3 个令你耳目一新的练手项目"),r(a)])])]),v])}const D=i(o,[["render",j],["__file","yicxzdmysqldbfyzxyhcsdms.html.vue"]]);export{D as default};
