import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as c,c as l,a as s,d as n,b as p,e as o}from"./app-72970f25.js";const i={},u=o('<h1 id="第三十节-fork-join" tabindex="-1"><a class="header-anchor" href="#第三十节-fork-join" aria-hidden="true">#</a> 第三十节：Fork/Join</h1><p>并发编程领域的任务可以分为三种：简单并行任务、聚合任务和批量并行任务，见下图。</p><figure><img src="https://cdn.tobebetterjavaer.com/paicoding/c9c8a3f8f15793db29c13849fccb475b.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这些模型之外，还有一种任务模型被称为“分治”。分治是一种解决复杂问题的思维方法和模式；具体而言，它将一个复杂的问题分解成多个相似的子问题，然后再将这些子问题进一步分解成更小的子问题，直到每个子问题变得足够简单从而可以直接求解。</p><p>从理论上讲，每个问题都对应着一个任务，因此分治实际上就是对任务的划分和组织。分治思想在许多领域都有广泛的应用。例如，在算法领域，我们经常使用分治算法来解决问题（如归并排序和快速排序都属于分治算法，二分查找也是一种分治算法）。在大数据领域，MapReduce 计算框架背后的思想也是基于分治。</p><p>由于分治这种任务模型的普遍性，Java 并发包提供了一种名为 Fork/Join 的并行计算框架，专门用于支持分治任务模型的应用。</p><h2 id="什么是分治任务模型" tabindex="-1"><a class="header-anchor" href="#什么是分治任务模型" aria-hidden="true">#</a> 什么是分治任务模型</h2><p>分治任务模型可分为两个阶段：一个阶段是 <strong>任务分解</strong>，就是迭代地将任务分解为子任务，直到子任务可以直接计算出结果；另一个阶段是 <strong>结果合并</strong>，即逐层合并子任务的执行结果，直到获得最终结果。下图是一个简化的分治任务模型图，你可以对照着理解。</p><figure><img src="https://cdn.tobebetterjavaer.com/paicoding/65e8b93caf76ef2ef1fc29cc5960f5ce.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在这个分治任务模型里，任务和分解后的子任务具有相似性，这种相似性往往体现在任务和子任务的算法是相同的，但是计算的数据规模是不同的。具备这种相似性的问题，我们往往都采用递归算法。</p><h2 id="fork-join-的使用" tabindex="-1"><a class="header-anchor" href="#fork-join-的使用" aria-hidden="true">#</a> Fork/Join 的使用</h2><p>Fork/Join 是一个并行计算框架，主要用于支持分治任务模型。在这个计算框架中，Fork 代表任务的分解，而 Join 代表结果的合并。</p><p>Fork/Join 计算框架主要由两部分组成：分治任务的线程池 ForkJoinPool 和分治任务 ForkJoinTask。</p>',13),r={href:"https://javabetter.cn/thread/pool.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://javabetter.cn/thread/wangzhe-thread.html",target:"_blank",rel:"noopener noreferrer"},d=o(`<p>ForkJoinTask 是一个抽象类，其中有许多方法，其中最核心的是 <code>fork()</code>方法和 <code>join()</code>方法。fork 方法用于异步执行一个子任务，而 join 方法通过阻塞当前线程来等待子任务的执行结果。</p><p>ForkJoinTask 有两个子类：RecursiveAction 和 RecursiveTask。</p><figure><img src="https://cdn.tobebetterjavaer.com/paicoding/256b6df2c13aa69a5d38b3f036d672d1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从它们的名字就可以看出，都是通过递归的方式来处理分治任务的。这两个子类都定义了一个抽象方法 <code>compute()</code>，不同之处在于 RecursiveAction 的 compute 方法没有返回值，而 RecursiveTask 的 compute 方法有返回值。这两个子类也都是抽象类，在使用时需要创建自定义的子类来扩展功能。</p><p>接下来，让我们使用 Fork/Join 并行计算框架来计算斐波那契数列（下面的代码示例源自 Java 官方示例）。</p><p>首先，我们需要创建一个 ForkJoinPool 线程池以及一个用于计算斐波那契数列的 Fibonacci 分治任务。然后，通过调用 ForkJoinPool 线程池的 <code>invoke()</code>方法来启动分治任务。</p><p>由于计算斐波那契数列需要返回结果，所以我们的 Fibonacci 类继承自 RecursiveTask。Fibonacci 分治任务需要实现 compute 方法，在这个方法中，逻辑与普通计算斐波那契数列的方法非常相似，只是在计算 <code>Fibonacci(n - 1)</code>时使用了异步子任务，这是通过 <code>f1.fork()</code>语句来实现。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Slf4j</span> 
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinDemo</span> <span class="token punctuation">{</span> 
     <span class="token comment">// 1. 运行入口 </span>
     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> 
  
         <span class="token comment">// 为了追踪子线程名称，需要重写 ForkJoinWorkerThreadFactory 的方法 </span>
         <span class="token keyword">final</span> <span class="token class-name">ForkJoinPool<span class="token punctuation">.</span>ForkJoinWorkerThreadFactory</span> factory <span class="token operator">=</span> pool <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> 
             <span class="token keyword">final</span> <span class="token class-name">ForkJoinWorkerThread</span> worker <span class="token operator">=</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span>defaultForkJoinWorkerThreadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span> 
             worker<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;my-thread&quot;</span> <span class="token operator">+</span> worker<span class="token punctuation">.</span><span class="token function">getPoolIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
             <span class="token keyword">return</span> worker<span class="token punctuation">;</span> 
         <span class="token punctuation">}</span><span class="token punctuation">;</span> 
  
         <span class="token comment">//创建分治任务线程池，可以追踪到线程名称 </span>
         <span class="token class-name">ForkJoinPool</span> forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> factory<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
         <span class="token comment">// 快速创建 ForkJoinPool 方法 </span>
         <span class="token comment">// ForkJoinPool forkJoinPool = new ForkJoinPool(4); </span>
  
         <span class="token comment">//创建分治任务 </span>
         <span class="token class-name">Fibonacci</span> fibonacci <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
         <span class="token comment">//调用 invoke 方法启动分治任务 </span>
         <span class="token class-name">Integer</span> result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span><span class="token punctuation">;</span> 
         log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Fibonacci {} 的结果是 {}&quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span> 
  
 <span class="token comment">// 2. 定义拆分任务，写好拆分逻辑 </span>
 <span class="token annotation punctuation">@Slf4j</span> 
 <span class="token keyword">class</span> <span class="token class-name">Fibonacci</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> 
     <span class="token keyword">final</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> 
     <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
  
     <span class="token annotation punctuation">@Override</span> 
     <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token comment">//和递归类似，定义可计算的最小单元 </span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
             <span class="token keyword">return</span> n<span class="token punctuation">;</span> 
         <span class="token punctuation">}</span> 
         <span class="token comment">// 想查看子线程名称输出的可以打开下面注释 </span>
         <span class="token comment">//log.info(Thread.currentThread().getName()); </span>
  
         <span class="token class-name">Fibonacci</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         <span class="token comment">// 拆分成子任务 </span>
         f1<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         <span class="token class-name">Fibonacci</span> f2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         <span class="token comment">// f1.join 等待子任务执行结果 </span>
         <span class="token keyword">return</span> f2<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> f1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行程序，我们会得到如下的结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>17:29:10.336 [main] INFO tech.shuyi.javacodechip.forkjoinpool.ForkJoinDemo - Fibonacci 20 的结果是 6765
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="forkjoinpool" tabindex="-1"><a class="header-anchor" href="#forkjoinpool" aria-hidden="true">#</a> ForkJoinPool</h2><p>Fork/Join 并行计算的核心组件是 ForkJoinPool。下面简单介绍一下 ForkJoinPool 的工作原理。</p><p>当我们通过 ForkJoinPool 的 invoke 或 submit 方法提交任务时，ForkJoinPool 会根据一定的路由规则将任务分配到一个任务队列中。如果任务执行过程中创建了子任务，那么子任务会被提交到对应工作线程的任务队列中。</p><p>ForkJoinPool 中有一个数组形式的成员变量 <code>workQueue[]</code>，其对应一个队列数组，每个队列对应一个消费线程。丢入线程池的任务，根据特定规则进行转发。</p><figure><img src="https://cdn.tobebetterjavaer.com/paicoding/4d74a32934994de9ea6661896bef7efa.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当工作线程的任务队列为空时，它是否无事可做呢？</p><p>不是的。ForkJoinPool 引入了一种称为&quot;任务窃取&quot;的机制。当工作线程空闲时，它可以从其他工作线程的任务队列中&quot;窃取&quot;任务。</p><figure><img src="https://cdn.tobebetterjavaer.com/paicoding/5a458499643f3a4564283b34ae29d6f5.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>例如，下图中线程 T2 的任务队列已经为空，它可以窃取线程 T1 任务队列中的任务。这样，所有的工作线程都能保持忙碌的状态。</p><figure><img src="https://cdn.tobebetterjavaer.com/paicoding/93e45106ddbb04387e8ae061eef1bfdf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>ForkJoinPool 中的任务队列采用双端队列的形式。工作线程从任务队列的一个端获取任务，而&quot;窃取任务&quot;从另一端进行消费。这种设计能够避免许多不必要的数据竞争。</p><h2 id="与threadpoolexecutor的比较" tabindex="-1"><a class="header-anchor" href="#与threadpoolexecutor的比较" aria-hidden="true">#</a> 与ThreadPoolExecutor的比较</h2><p>ForkJoinPool 与 ThreadPoolExecutor 有很多相似之处，例如都是线程池，都是用于执行任务的。但是，它们之间也有很多不同之处。</p><p>首先，ForkJoinPool 采用的是&quot;工作窃取&quot;的机制，而 ThreadPoolExecutor 采用的是&quot;工作复用&quot;的机制。这两种机制各有优劣，ForkJoinPool 的优势在于能够充分利用 CPU 的多核能力，而 ThreadPoolExecutor 的优势在于能够避免线程间的上下文切换。</p><p>其次，ForkJoinPool 采用的是分治任务模型，而 ThreadPoolExecutor 采用的是简单并行任务模型。这两种任务模型各有优劣，ForkJoinPool 的优势在于能够处理分治任务，而 ThreadPoolExecutor 的优势在于能够处理简单并行任务。</p><p>最后，ForkJoinPool 采用的是 LIFO 的任务队列，而 ThreadPoolExecutor 采用的是 FIFO 的任务队列。这两种任务队列各有优劣，ForkJoinPool 的优势在于能够避免数据竞争，而 ThreadPoolExecutor 的优势在于能够保证任务的顺序性。</p><p>假设：我们要计算 1 到 1 亿的和，为了加快计算的速度，我们自然想到算法中的分治原理，将 1 亿个数字分成 1 万个任务，每个任务计算 1 万个数值的综合，利用 CPU 的并发计算性能缩短计算时间。</p>`,27),m={href:"https://javabetter.cn/thread/callable-future-futuretask.html",target:"_blank",rel:"noopener noreferrer"},v=o(`<p>当然 ForkJoinPool 实现也是可以的。下面我们将这两种方式都实现一下，看看这两种实现方式有什么不同。</p><p>无论哪种实现方式，其大致思路都是：</p><ol><li>按照线程池里线程个数 N，将 1 亿个数划分成 N 等份，随后丢入线程池进行计算。</li><li>每个计算任务使用 Future 接口获取计算结果，最后积加即可。</li></ol><p>我们先使用 ThreadPoolExecutor 实现。</p><p>首先，定义一个 Calculator 接口，表示计算数字总和这个动作，如下所示。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span> 
     <span class="token doc-comment comment">/** 
      * 把传进来的所有numbers 做求和处理 
      * 
      * @param numbers 
      * @return 总和 
      */</span> 
     <span class="token keyword">long</span> <span class="token function">sumUp</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，我们定义一个使用 ThreadPoolExecutor 线程池实现的类，如下所示。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecutorServiceCalculator</span> <span class="token keyword">implements</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span> 
  
     <span class="token keyword">private</span> <span class="token keyword">int</span> parallism<span class="token punctuation">;</span> 
     <span class="token keyword">private</span> <span class="token class-name">ExecutorService</span> pool<span class="token punctuation">;</span> 
  
     <span class="token keyword">public</span> <span class="token class-name">ExecutorServiceCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token comment">// CPU的核心数 默认就用cpu核心数了 </span>
         parallism <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
         pool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>parallism<span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
  
     <span class="token comment">// 1. 处理计算任务的线程 </span>
     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SumTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> 
         <span class="token keyword">private</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">;</span> 
         <span class="token keyword">private</span> <span class="token keyword">int</span> from<span class="token punctuation">;</span> 
         <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">;</span> 
  
         <span class="token keyword">public</span> <span class="token class-name">SumTask</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
             <span class="token keyword">this</span><span class="token punctuation">.</span>numbers <span class="token operator">=</span> numbers<span class="token punctuation">;</span> 
             <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> from<span class="token punctuation">;</span> 
             <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span> 
         <span class="token punctuation">}</span> 
  
         <span class="token annotation punctuation">@Override</span> 
         <span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
             <span class="token keyword">long</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
             <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> from<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token keyword">to</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                 total <span class="token operator">+=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> 
             <span class="token punctuation">}</span> 
             <span class="token keyword">return</span> total<span class="token punctuation">;</span> 
         <span class="token punctuation">}</span> 
     <span class="token punctuation">}</span> 
  
     <span class="token comment">// 2. 核心业务逻辑实现 </span>
     <span class="token annotation punctuation">@Override</span> 
     <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sumUp</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
         <span class="token comment">// 2.1 数字拆分 </span>
         <span class="token comment">// 把任务分解为 n 份，交给 n 个线程处理   4核心 就等分成4份呗 </span>
         <span class="token comment">// 然后把每一份都扔个一个SumTask线程 进行处理 </span>
         <span class="token keyword">int</span> part <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length <span class="token operator">/</span> parallism<span class="token punctuation">;</span> 
         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> parallism<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
             <span class="token keyword">int</span> from <span class="token operator">=</span> i <span class="token operator">*</span> part<span class="token punctuation">;</span> <span class="token comment">//开始位置 </span>
             <span class="token keyword">int</span> <span class="token keyword">to</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> parallism <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> numbers<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> part <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//结束位置 </span>
  
             <span class="token comment">//扔给线程池计算 </span>
             results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SumTask</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         <span class="token punctuation">}</span> 
  
         <span class="token comment">// 2.2 阻塞等待结果 </span>
         <span class="token comment">// 把每个线程的结果相加，得到最终结果 get()方法 是阻塞的 </span>
         <span class="token comment">// 优化方案：可以采用CompletableFuture来优化  JDK1.8的新特性 </span>
         <span class="token keyword">long</span> total <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span> 
         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">:</span> results<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
             <span class="token keyword">try</span> <span class="token punctuation">{</span> 
                 total <span class="token operator">+=</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
             <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
             <span class="token punctuation">}</span> 
         <span class="token punctuation">}</span> 
  
         <span class="token keyword">return</span> total<span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上面代码所示，我们实现了一个计算单个任务的类 SumTask，在该类中对数值进行累加。其次，我们在 <code>sumUp ()</code> 方法中，对 1 亿的数字进行拆分，接着扔给线程池计算，最后阻塞等待计算结果，最终累加起来。</p><p>我们运行上面的代码，可以得到顺利得到最终结果，如下所示。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>耗时：10ms 
 结果为：50000005000000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接着我们使用 ForkJoinPool 来实现。</p><p>我们首先实现 SumTask 继承 RecursiveTask 抽象类，并在 compute 方法中定义拆分逻辑及计算。最后在 sumUp 方法中调用 pool 方法进行计算，代码如下所示。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinCalculator</span> <span class="token keyword">implements</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span> 
  
     <span class="token keyword">private</span> <span class="token class-name">ForkJoinPool</span> pool<span class="token punctuation">;</span> 
  
     <span class="token comment">// 1. 定义计算逻辑 </span>
     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SumTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> 
         <span class="token keyword">private</span> <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">;</span> 
         <span class="token keyword">private</span> <span class="token keyword">int</span> from<span class="token punctuation">;</span> 
         <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">;</span> 
  
         <span class="token keyword">public</span> <span class="token class-name">SumTask</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
             <span class="token keyword">this</span><span class="token punctuation">.</span>numbers <span class="token operator">=</span> numbers<span class="token punctuation">;</span> 
             <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> from<span class="token punctuation">;</span> 
             <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span> 
         <span class="token punctuation">}</span> 
  
         <span class="token comment">//此方法为ForkJoin的核心方法：对任务进行拆分  拆分的好坏决定了效率的高低 </span>
         <span class="token annotation punctuation">@Override</span> 
         <span class="token keyword">protected</span> <span class="token class-name">Long</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  
             <span class="token comment">// 当需要计算的数字个数小于6时，直接采用for loop方式计算结果 </span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">to</span> <span class="token operator">-</span> from <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                 <span class="token keyword">long</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
                 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> from<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token keyword">to</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                     total <span class="token operator">+=</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> 
                 <span class="token punctuation">}</span> 
                 <span class="token keyword">return</span> total<span class="token punctuation">;</span> 
             <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  
                 <span class="token comment">// 否则，把任务一分为二，递归拆分(注意此处有递归)到底拆分成多少分 需要根据具体情况而定 </span>
                 <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>from <span class="token operator">+</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> 
                 <span class="token class-name">SumTask</span> taskLeft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SumTask</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> from<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span> 
                 <span class="token class-name">SumTask</span> taskRight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SumTask</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
                 taskLeft<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
                 taskRight<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
                 <span class="token keyword">return</span> taskLeft<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> taskRight<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
             <span class="token punctuation">}</span> 
         <span class="token punctuation">}</span> 
     <span class="token punctuation">}</span> 
  
     <span class="token keyword">public</span> <span class="token class-name">ForkJoinCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token comment">// 也可以使用公用的线程池 ForkJoinPool.commonPool()： </span>
         <span class="token comment">// pool = ForkJoinPool.commonPool() </span>
         pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
  
     <span class="token annotation punctuation">@Override</span> 
     <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sumUp</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token class-name">Long</span> result <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SumTask</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> numbers<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         pool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         <span class="token keyword">return</span> result<span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行上面的代码，结果为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>耗时：860ms 
 结果为：50000005000000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对比 ThreadPoolExecutor 和 ForkJoinPool 这两者的实现，可以发现它们都有任务拆分的逻辑，以及最终合并数值的逻辑。但 ForkJoinPool 相比 ThreadPoolExecutor 来说，做了一些实现上的封装，例如：</p><ul><li>不用手动去获取子任务的结果，而是使用 join 方法直接获取结果。</li><li>将任务拆分的逻辑，封装到 RecursiveTask 实现类中，而不是裸露在外。</li></ul><p>因此对于没有父子任务依赖，但是希望获取到子任务执行结果的并行计算任务，就可以使用 ForkJoinPool 来实现。<strong>在这种情况下，使用 ForkJoinPool 实现更多是代码实现方便，封装做得更加好。</strong></p><h2 id="模拟-mapreduce-统计单词数量" tabindex="-1"><a class="header-anchor" href="#模拟-mapreduce-统计单词数量" aria-hidden="true">#</a> 模拟 MapReduce 统计单词数量</h2><p>MapReduce 是一个编程模型，同时也是一个处理和生成大数据集的处理框架。它源于 Google，用于支持在大型数据集上的分布式计算。这个框架主要由两个步骤组成：Map 步骤和 Reduce 步骤，这也是它名字的由来。</p><p>Fork/Join 并行计算框架通常被用来实现学习 MapReduce 的入门程序，该程序用于统计文件中每个单词的数量。</p><p>首先，我们可以使用二分法递归地将文件拆分为更小的部分，直到每个部分只有一行数据。然后，在每个部分中统计单词的数量，并逐级汇总结果。你可以参考之前提到的简化版分治任务模型图来理解该过程。</p><p>现在，让我们开始实现。下面的代码使用了字符串数组<code>String[] fc</code>来模拟文件内容，其中每个元素与文件中的行数据一一对应。关键代码位于<code>compute()</code>方法中，这是一个递归方法。它将前半部分数据 fork 一个递归任务进行处理（关键代码：<code>mr1.fork()</code>），而后半部分数据在当前任务中递归处理（<code>mr2.compute()</code>）。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">RecursiveTask</span></span><span class="token punctuation">;</span>

 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
     <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fc<span class="token punctuation">;</span>
     <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>
     
     <span class="token keyword">public</span> <span class="token class-name">WordCountTask</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fc<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>fc <span class="token operator">=</span> fc<span class="token punctuation">;</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">protected</span> <span class="token class-name">Integer</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment">// 对单行数据进行统计</span>
             <span class="token keyword">return</span> <span class="token function">countWords</span><span class="token punctuation">(</span>fc<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
             <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
             <span class="token class-name">WordCountTask</span> mr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WordCountTask</span><span class="token punctuation">(</span>fc<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
             mr1<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">WordCountTask</span> mr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WordCountTask</span><span class="token punctuation">(</span>fc<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token keyword">int</span> result2 <span class="token operator">=</span> mr2<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token keyword">int</span> result1 <span class="token operator">=</span> mr1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment">// 汇总结果</span>
             <span class="token keyword">return</span> result1 <span class="token operator">+</span> result2<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     
     <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">countWords</span><span class="token punctuation">(</span><span class="token class-name">String</span> line<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> words <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> words<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个示例程序是对 Fork/Join 模型的简化，实际上在真正的 MapReduce 框架中，还涉及到数据划分、映射阶段、归约阶段等更多的步骤。但是通过此示例，大家可以初步了解如何使用 Fork/Join 并行计算框架来处理类似的任务。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>Fork/Join 并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。这个过程非常类似于大数据处理中的 MapReduce，所以你可以把 Fork/Join 看作单机版的 MapReduce。</p><p>Fork/Join 并行计算框架的核心组件是 ForkJoinPool。ForkJoinPool 支持任务窃取机制，能够让所有线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。</p><figure><img src="https://cdn.tobebetterjavaer.com/paicoding/607bb6ad3e7316b0693a8ff1e248a968.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Java 1.8 提供的 Stream API 里面并行流也是以 ForkJoinPool 为基础的。不过需要注意的是，默认情况下所有的并行流计算都共享一个 ForkJoinPool，这个共享的 ForkJoinPool 默认的线程数是 CPU 的核数；如果所有的并行流计算都是 CPU 密集型计算的话，完全没有问题，但是如果存在 I/O 密集型的并行流计算，那么很可能会因为一个很慢的 I/O 计算而拖慢整个系统的性能。</p><p>所以 <strong>建议用不同的 ForkJoinPool 执行不同类型的计算任务</strong>。</p>`,32),b={href:"https://mp.weixin.qq.com/s/baP7S6tA9i_Hgu6RhKcvew",target:"_blank",rel:"noopener noreferrer"},f={href:"https://mp.weixin.qq.com/s/0jCBRPJBPYlgQ0iPByXDtw",target:"_blank",rel:"noopener noreferrer"},g=s("hr",null,null,-1),w={href:"https://github.com/itwanger/toBeBetterJavaer",target:"_blank",rel:"noopener noreferrer"},y={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},F={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},J={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},P=s("figure",null,[s("img",{src:"https://cdn.tobebetterjavaer.com/stutymore/wangzhe-thread-20230904125125.png",alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1);function x(T,j){const a=t("ExternalLinkIcon");return c(),l("div",null,[u,s("p",null,[n("这两部分的关系类似于 "),s("a",r,[n("ThreadPoolExecutor"),p(a)]),n(" 和 "),s("a",k,[n("Runnable"),p(a)]),n(" 之间的关系，都是用于提交任务到线程池的，只不过分治任务有自己独特的类型 ForkJoinTask。")]),d,s("p",null,[n("由于 ThreadPoolExecutor 可以通过 "),s("a",m,[n("Future"),p(a)]),n(" 获取到执行结果，因此利用 ThreadPoolExecutor 也是可行的。")]),v,s("blockquote",null,[s("p",null,[n("编辑：沉默王二，部分内容来源于这篇文章："),s("a",b,[n("分而治之思想Forkjoin"),p(a)]),n("，还有一部分内容来源于朋友"),s("a",f,[n("陈树义的这篇文章"),p(a)]),n("，内容很顶，强烈推荐。还有一部分图片来自于朋友「日拱一兵」的文章。")])]),g,s("p",null,[n("GitHub 上标星 10000+ 的开源知识库《"),s("a",w,[n("二哥的 Java 进阶之路"),p(a)]),n("》第二份 PDF 《"),s("a",y,[n("并发编程小册"),p(a)]),n("》终于来了！包括线程的基本概念和使用方法、Java的内存模型、sychronized、volatile、CAS、AQS、ReentrantLock、线程池、并发容器、ThreadLocal、生产者消费者模型等面试和开发必须掌握的内容，共计 15 万余字，200+张手绘图，可以说是通俗易懂、风趣幽默……详情戳："),s("a",h,[n("太赞了，二哥的并发编程进阶之路.pdf"),p(a)])]),s("p",null,[s("a",F,[n("加入二哥的编程星球"),p(a)]),n("，在星球的第二个置顶帖「"),s("a",J,[n("知识图谱"),p(a)]),n("」里就可以获取 PDF 版本。")]),P])}const R=e(i,[["render",x],["__file","fork-join.html.vue"]]);export{R as default};
