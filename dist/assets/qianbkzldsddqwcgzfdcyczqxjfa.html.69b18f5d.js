import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c as t,a as p,d as a,b as n,e as i,r as h}from"./app.99eb8281.js";const l={},s=i('<h2 id="掉单异常" tabindex="-1"><a class="header-anchor" href="#掉单异常" aria-hidden="true">#</a> 掉单异常</h2><p>一个最常见的支付平台架构关系如下所示：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859085-1227418818.jpg" alt="" loading="lazy"></p><blockquote><p>上图我们是站在第三方支付公司支付角度，如果是自己公司的内部支付系统，那么外部商户这一块其实就是公司内部一些系统，比如说订单系统，而外部支付渠道其实就是第三方支付公司</p></blockquote><p>我们以携程为例，在其上面发起一笔订单支付，将会经过三个系统：</p><ol><li>携程创建订单，向第三方支付公司发起支付请求</li><li>第三方支付公司创建订单，并向工行发起支付请求</li><li>工行完成扣款操作，返回第三方支付公司</li><li>第三方支付完成订单更新并返回携程</li><li>携程变更订单状态</li></ol><p>上面的流程，简单如下图所示：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859313-868801941.jpg" alt="" loading="lazy"></p><p>在这个过程就可能会碰到，用户工行卡已经扣款，但是携程订单却还是待支付，我们通常将这种情况称为<strong>掉单</strong>。</p><p>上述掉单的场景，多数是因为<strong>③、⑤</strong>环节信息丢失导致，这种掉单我们将其称为<strong>外部掉单</strong>。</p><p>还有一种极少数的情况，收到 <strong>③、⑤</strong>环节返回信息，但是在<strong>④、⑥</strong>环节内部系统更新订单状态失败，从而导致丢失支付成功的信息，这类掉单由于是内部问题，我们通常将其称之为<strong>内部掉单</strong>。</p><h2 id="外部掉单" tabindex="-1"><a class="header-anchor" href="#外部掉单" aria-hidden="true">#</a> 外部掉单</h2><p>外部掉单是因为没有收到对端返回信息，这种情况极有可能是网络问题，也有可能对端处理逻辑太慢，导致我方请求超时，直接断开了网络请求。</p><h3 id="增加超时时间" tabindex="-1"><a class="header-anchor" href="#增加超时时间" aria-hidden="true">#</a> 增加超时时间</h3><p>对于这种情况，第一个最简单的解决办法，<strong>适当的增加超时时间</strong>。</p><p>不过这里需要注意了，在我们增加网络超时时间之后，我们可能还需要调整整个链路的超时时间，不然有可能导致整个链路内部差事从而引起内部掉单。</p><blockquote><p>画外音：对接外部渠道，一定要<strong>设置网络连接超时时间与读取超时时间</strong>。</p></blockquote><h3 id="接收异步通知" tabindex="-1"><a class="header-anchor" href="#接收异步通知" aria-hidden="true">#</a> 接收异步通知</h3><p>第二个办法，接收渠道异步回执通知信息。</p><p>一般来说，现在支付渠道接口我们都可以上送一个异步回调地址，当渠道端处理成功，将会把成功信息通知到这个回调地址上。</p><p>这种情况下，我们只需要接收通知信息，然后解析，再更新内部订单状态。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859492-1898161292.jpg" alt="支付系统异常处理-支付异步通知" loading="lazy"></p><p>这种情况下，我们需要注意几点：</p><ol><li>对于异步请求信息，一定需要对通知内容进行签名验证，并校验返回的订单金额是否与商户侧的订单金额一致，防止数据泄漏导致出现“假通知”，造成资金损失。</li><li>异步通知将会发送多次，所以异步通知处理需要幂等。</li></ol><h3 id="掉单查询" tabindex="-1"><a class="header-anchor" href="#掉单查询" aria-hidden="true">#</a> 掉单查询</h3><p>有的渠道可能没有提供异步通知的功能，只提供了订单查询的接口，这种情况下，我们只能使用第三种解决办法，定时掉单查询。</p><p>我们可以将这类超时未知的订单的单独保存到掉单表，然后定时向渠道端查询订单的状态。</p><p>若查询成功或者明确失败（比如订单不存在等），可以更新订单状态，并且删除掉单表记录。</p><p>若查询依旧未知，这时我们需要等待下次查询的结果。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859615-1762843903.jpg" alt="支付系统异常处理-定时查询" loading="lazy"></p><p>这里我们需要注意了，有些情况下，有可能无法查询返回订单的状态，所以我们需要设置订单查询的最大次数，防止无限查询浪费性能。</p><h3 id="对账" tabindex="-1"><a class="header-anchor" href="#对账" aria-hidden="true">#</a> 对账</h3><p>最后，极少数的情况下，订单查询与异步通知都无法获取的支付结果，这就还剩下最后一种兜底的解决办法，对账。</p><p>如果第二天渠道端给的对账文件有这一笔支付结果，那么我们可以根据这个记录更新直接更新我们内部支付记录。</p><blockquote><p>画外音：稳妥一点，可以先发起查询，然后根据查询结果更新订单记录。</p><p>不过有些极端情况，查询无法获取结果，那么直接更新内部记录即可。</p></blockquote><p>那如果第二天也没有这笔记录的结果，这种情况下，我们可以认为这笔是失败的。如果用户被扣款，渠道端内部将会发起退款，将支付金额返回给用户。所以这种情况可以无需处理。</p><h2 id="内部掉单异常" tabindex="-1"><a class="header-anchor" href="#内部掉单异常" aria-hidden="true">#</a> 内部掉单异常</h2><h3 id="支付公司内部订单关系" tabindex="-1"><a class="header-anchor" href="#支付公司内部订单关系" aria-hidden="true">#</a> 支付公司内部订单关系</h3><p>接下来我们讲下内部掉单异常，首先我们来看下为什么会发生内部掉单的异常，这其实跟我们系统架构有关。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859756-1011257296.jpg" alt="" loading="lazy"></p><p>如上图随所示，第三方支付公司内部表通常为支付订单与渠道订单这样一种 1 比 N 的关系。</p><p>支付订单保存着外部商户系统的订单号，代表第三方支付公司内部订单与外部商户的订单的关系。</p><p>而渠道订单代表着第三方支付公司与外部渠道的关系，其实对于外部渠道系统来讲，第三方支付公司就是一个外部商户。</p><p>为什么需要设计这种关系那？而不是使用下面这种 1 对 1 关系的那？</p><p><img src="https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083859966-155602254.jpg" alt="" loading="lazy"></p><p>如果我们使用上图 1 对1 的订单关系，如果第一次支付支付失败，外部商户可能会再次使用相同订单号对第三方支付公司发起支付。</p><p>这时如果第三方支付公司也拿相同的内部订单去请求外部渠道系统，有可能外部渠道系统并不支持同一订单号再次请求。</p><p>那其实我们也有其他办法，生成一个新的内部单号，更新原有支付订单上内部记录，然后去请求外部渠道系统。但是这样的话就会丢失上次支付失败记录，这就不利于我们做一些事后统计了。</p><p>那其实第三方支付公司也可以不支持相同的订单号再次发起请求，但是这样的话，就需要外部商户重新生成的新的订单号。</p><p>这样的话，第三方支付公司是系统是简单了，全部复杂度都交给了外部商户。</p><p>但是现实的情况，很多外部商户并不是那么容易更换生成新的订单号，所以一般第三方支付公司都需要支持同一外部商户订单号在未成功的情况下，支持重复支付。</p><p>在这种情况下，就需要我们上面的 1:N 的订单关系图了。</p><h3 id="内部掉单异常的原因" tabindex="-1"><a class="header-anchor" href="#内部掉单异常的原因" aria-hidden="true">#</a> 内部掉单异常的原因</h3><p>当我们收到外部渠道系统的成功的返回信息，成功更新了渠道订单表的记录。但是由于渠道订单表与支付订单表可能不是同一个数据库，也有可能两者并不在同一个应用中，这就有可能导致更新支付订单表的更新失败。</p><p><img src="https://img2020.cnblogs.com/other/1419561/202010/1419561-20201012083900191-2087810427.jpg" alt="" loading="lazy"></p><p>由于支付订单是表保存着外部商户订单与内部订单关系，支付订单未成功，所以外部商户也无法查询得到成功的支付结果。</p><p>此时渠道订单表已经成功，所以上面外部掉单的方法并不适用内部掉单。</p><h3 id="内部掉单异常解决办法" tabindex="-1"><a class="header-anchor" href="#内部掉单异常解决办法" aria-hidden="true">#</a> 内部掉单异常解决办法</h3><p><strong>第一种解决办法，分布式事务。</strong></p><p>内部掉单异常，说白就是因为支付订单表与渠道订单表无法使用数据库事务保证两者同时更新成功或失败。</p><p>那么这种情况下，我们其实就需要使用分布式事务了。</p><p>不过我们没有采用这种分布式事务，一是因为之前开发的时候市面上并没有开源成熟分布式事务框架，第二自己自己开发难度又很大。</p><p>所以对于分布式事务这一块，并没有什么使用经验。如果有使用分布式事务解决这类的问题同学，留言去可以评论一下。</p><p><strong>第二种解决办法，异步补偿更新。</strong></p><p>当发生内部掉单的情况，即更新支付订单失败等情况，可以将这里支付订单保存到一张内部掉单表。</p><p>但是这里可能会有一个问题，我们无法保证保存到内部掉单表这一步骤也一定成功。</p><p>所以说，我们还需要定时查询，查询一段时间内支付订单未成功，而渠道订单表已成功的支付订单记录，然后也将其插入到内部掉单表。</p><p>另一个系统应用，只需要定时扫描内部掉单表，将支付订单成功，然后再删除内部掉单记录即可。</p><p>这里需要注意了，当支付订单表数据量很大之后，定时查询可能会慢，为了防止影响主库，所以这类查询可以在备库进行。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>今天主要介绍了支付系统中的掉单异常，这类异常往往会导致用户实际已经被扣钱，但是商户订单还是等待支付的情况。</p><p>这个异常如果没有很好处理，将会导致客户用户体验很不好，还有可能收到客户的投诉。</p><p>掉单的异常，通常可以外部系统与内部系统。而大部分的掉单都是因为外部系统导致，我们可以增加超时时间，掉单查询，以及接受异步通知解决 99% 的问题，剩下 1% 的掉单只能通过次日的对账来兜底。</p><p>内部系统导致掉单异常是典型的分布式环境数据一致性的问题，这类问题我们可以不需要追求强一致性，只要保证最终一致性即可。我们可以使用分布式事务解决这类问题，也可以定时扫描状态不一致的订单，然后在做批量更新。</p>',74),d={href:"https://www.cnblogs.com/goodAndyxublog/p/13800796.html",target:"_blank",rel:"noopener noreferrer"};function c(g,m){const e=h("ExternalLinkIcon");return r(),t("div",null,[s,p("blockquote",null,[p("p",null,[a("参考链接："),p("a",d,[a("https://www.cnblogs.com/goodAndyxublog/p/13800796.html"),n(e)]),a("，整理：沉默王二")])])])}const f=o(l,[["render",c],["__file","qianbkzldsddqwcgzfdcyczqxjfa.html.vue"]]);export{f as default};
