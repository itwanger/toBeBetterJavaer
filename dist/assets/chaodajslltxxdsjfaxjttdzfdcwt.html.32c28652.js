import{_ as r}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c as p,a,d as e,b as s,e as t,r as l}from"./app.99eb8281.js";const i={},d=t('<p>之前提到，支付过程会出现<strong>掉单、卡单</strong>的情况，这种情况对于用户来讲，体验非常差，明明自己付了钱，扣了款，但是订单却未成功。</p><p>前面我们简单说了下解决方案，这次就结合生产实际碰到的情况，给出两种详细设计的方案：</p><ul><li>定时轮询补偿方案</li><li>延迟消息补偿方案</li></ul><p>大家可以根据自己系统的实际情况，选择性参考。</p><h2 id="定时轮询补偿方案" tabindex="-1"><a class="header-anchor" href="#定时轮询补偿方案" aria-hidden="true">#</a> 定时轮询补偿方案</h2><h3 id="整体流程" tabindex="-1"><a class="header-anchor" href="#整体流程" aria-hidden="true">#</a> 整体流程</h3><p>这个方案主要采用定时任务，批量查询掉单记录，从而驱动查询具体支付支付结果，然后更新内部订单。</p><p>整体方案流程图如下：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202101/1419561-20210107083620714-1094767745.jpg" alt="定时任务补偿" loading="lazy"></p><p>前三步流程没什么好说的，正常的支付流程，咱们针对后面几步具体详细说下。</p><p>第三步调用支付通道之后，如果支付通道端返回<strong>支付受理成功或者支付处理中</strong>，我们就需要调用第四步，将这类订单插入掉单表。</p><p>如果支付直接成功了，那就正常流程返回即可。</p><blockquote><p>复习一下，网关类支付，比如支付宝、微信支付、网银支付，这种支付模式，支付通道仅仅返回支付受理成功，具体支付结果需要接收支付通道端的支付通知，这类支付我们将其称为异步支付。</p><p>相应的还有同步支付，比如银行卡支付，微信、支付宝代扣类支付，这类支付，同步就能返回支付结果。</p></blockquote><p>第五步，补单应用将会定时查询数据库，批量查询掉单记录。</p><p>第六步，补单应用使用线程池，多线程异步的方式发起掉单查询。</p><p>第七步，调用支付通道支付查询接口。</p><p>重点来了，如果第七步支付结果查询为以下状态：</p><ul><li><strong>支付结果为扣款成功</strong></li><li><strong>支付结果为明确失败</strong></li><li><strong>掉单记录查询达到最大次数</strong></li></ul><p><strong>第八步就会删除掉单记录。</strong></p><p>最后，如果掉单查询依旧还是处理中，那么经过一定的延时之后，重复第五步，再次重新掉单补偿，直到成功或者查询到达最大次数。</p><h3 id="相关问题" tabindex="-1"><a class="header-anchor" href="#相关问题" aria-hidden="true">#</a> 相关问题</h3><p><strong>为什么需要新建一张掉单表？不能直接使用支付订单表，查询未成功的订单吗?</strong></p><p>这个问题，实际上确实可以直接使用的支付订单表，然后批量查询当天未成功的订单，补单程序发起支付查询。</p><p><em>那为什么需要新建一张掉单表？</em></p><p>主要是因为数据库查询效率问题，因为支付订单表每天都会大量记录新增，随着时间，这张表记录将会越来越多，越来越大。</p><p><strong>支付记录越多，批量范围查询效率就会变低，查询速度将会变慢。</strong></p><p>所以为了查询效率，新建一张掉单表。</p><p>这张表里仅记录支付未成功的订单，所以数据量就会很小，那么查询效率就会很高。</p><p>另外，掉单表里的记录，不会被永久保存，只是临时性。当支付结果查询成功，或者支付结果明确失败，再或者查询次数到达规定最大次数，就会删除掉单记录。</p><p><strong>这就是第八步为什么需要删除掉单表的原因。</strong></p><p>如果需要保存每次掉单表查询详情，那么这里建议再新增一张掉单查询记录表，保存每一次的查询记录。</p><p>针对这个方案，如果还有其他问题，欢迎留言。</p><h3 id="方案优缺点" tabindex="-1"><a class="header-anchor" href="#方案优缺点" aria-hidden="true">#</a> 方案优缺点</h3><p>定时轮询补偿方案，最大的优点可能就是系统架构方案比较简单，比较容易实施。</p><p>那么这个方案的缺点主要在于<strong>定时任务</strong>上。</p><p>定时任务轮询方案天然会存在以下不足：</p><ol><li><strong>轮询效率稍低</strong></li><li>每次查询数据库，已经被执行过记录，仍然会被扫描（补单程序将会根据一定策略决定是否发起支付通道查询），有<strong>重复计算</strong>的嫌疑</li><li><strong>时效性不够好</strong>，如果每小时轮询一次，最差的情况下，时间误差会达到1小时</li><li>如果为了解决时效性问题，增加定时任务查询效率，那么 1 中查询效率跟 2 的重复计算问题将会更加明显。</li></ol><h2 id="延迟消息补偿方案" tabindex="-1"><a class="header-anchor" href="#延迟消息补偿方案" aria-hidden="true">#</a> 延迟消息补偿方案</h2><p>下面介绍另外一种掉单补偿方案，延迟消息补偿方案，这个方案整体流程与定时任务方案类似，最大区别可能在于，从一种<strong>拉模式</strong>变成一种<strong>推模式</strong>。</p><p>整体方案流程图如下：</p><p><img src="https://img2020.cnblogs.com/other/1419561/202101/1419561-20210107083620916-1904350166.jpg" alt="" loading="lazy"></p><p>这个方案主要流程跟定时方案类似，主要区别在于第四步，第五步，第八步。</p><p>第四步的流程从插入掉单表变更为往<strong>延迟队列发送掉单消息</strong>。</p><p>第五步，补单程序接收掉单消息，然后触发支付掉单查询。</p><p>第八步，如果第七步支付结果查询为以下状态：</p><ul><li>支付结果为扣款成功</li><li>支付结果为明确失败</li><li>掉单记录查询达到最大次数</li></ul><p>补单程序将会告知延迟队列消费成功，延迟队列将会删除这条掉单消息。</p><p>其他状态将会告知消费失效，延迟队列将会在一定延时之后，再次发送掉单消息，然后继续重复第五步。</p><h3 id="延迟队列" tabindex="-1"><a class="header-anchor" href="#延迟队列" aria-hidden="true">#</a> 延迟队列</h3><p>这里的延迟队列需要自己实现，复杂度还是比较高的，这里给大家推荐几种实现方案：</p>',50),c=a("strong",null,"Redis SortedSet",-1),h={href:"https://tech.youzan.com/queuing_delay/",target:"_blank",rel:"noopener noreferrer"},g=t(`<p>第二种，基于时间轮算法(<strong>TimingWheel</strong>)实现延迟队列，具体可以参考 Kafka 延时队列。</p><p>第三种，基于 <strong>RocketMQ</strong> 延迟消息。</p><p>前两种方案说起来还需要再开发，所以还是比较复杂的。</p><p>这里重点说下第三种方案，该方案是 <strong>RocketMQ</strong> 已经支持的特性，开箱即用，使用起来还是比较简单的。</p><p>RocketMQ 延迟消息支持 18 个等级，分别如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>消息发送方可以通过以下方式指定延迟等级，对应上方的延迟时间。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Message</span>#setDelayTimeLevel
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>消息消费方，如果消费失败，默认将会在消息发送方的的延迟等级基础上加 1。如果消息消费方需要指定其他的延迟等级，可以使用如下方式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ConsumeConcurrentlyContext</span>#setDelayLevelWhenNextConsume
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>RocketMQ 延迟消息，支持的特性还是比较基础、简单，不支持自定义延迟时间。不过对于掉单补偿的这个场景刚好够用，但是如果需要自定义延迟的，那还是得采用其他的方案。</p><h3 id="方案优缺点-1" tabindex="-1"><a class="header-anchor" href="#方案优缺点-1" aria-hidden="true">#</a> 方案优缺点</h3><p>延迟消息的方案相对于定时轮询方案来讲：</p><ul><li>无需再查询全部订单，效率高</li><li>时效性较好</li></ul><p>不过延迟消息这种方案，需要基于<strong>延迟队列</strong>，实现起来比较复杂，目前开源实现也比较少。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>支付掉单、卡单是支付过程中经常会碰到的事，我们可以采用异步补偿的方案，解决该问题。</p><p>异步补偿方案可以采用如下两种：</p><ul><li>定时轮询补偿方案</li><li>延迟消息补偿方案</li></ul><p>定时轮询补偿方案实现起来比较简单，但是时效性稍差。</p><p>而延迟消息补偿方案总体来说比较优秀，但是实现起来比较复杂。如果没有自定义的延迟时间的需求，可以直接采用 RocketMQ 延迟消息，简单快捷。</p><p>另外<strong>延迟队列</strong>使用场景还是比较多，不仅仅能用在掉单补偿上，还可以用于支付关单等场景。所以有能力开发的团队，可以开发一个通用的延迟队列、</p>`,22),u={href:"https://www.cnblogs.com/goodAndyxublog/p/14244458.html",target:"_blank",rel:"noopener noreferrer"};function m(b,v){const n=l("ExternalLinkIcon");return o(),p("div",null,[d,a("p",null,[e("第一种，基于 "),c,e(" 实现延迟队列。可以参考一下有赞的实现方案"),a("a",h,[e("https://tech.youzan.com/queuing_delay/"),s(n)])]),g,a("blockquote",null,[a("p",null,[e("参考链接："),a("a",u,[e("https://www.cnblogs.com/goodAndyxublog/p/14244458.html"),s(n)]),e("，整理：沉默王二")])])])}const f=r(i,[["render",m],["__file","chaodajslltxxdsjfaxjttdzfdcwt.html.vue"]]);export{f as default};
