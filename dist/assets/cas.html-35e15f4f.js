import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as c,c as l,a as n,d as a,b as e,e as t}from"./app-72970f25.js";const r={},i=n("h1",{id:"第十二节-乐观锁-cas",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#第十二节-乐观锁-cas","aria-hidden":"true"},"#"),a(" 第十二节：乐观锁 CAS")],-1),d=n("p",null,"CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为“比较并交换”，是一种无锁的原子操作。",-1),u=n("code",null,"i++",-1),k=n("code",null,"i++",-1),h={href:"https://javabetter.cn/thread/thread-bring-some-problem.html",target:"_blank",rel:"noopener noreferrer"},v=n("p",null,[n("strong",null,"如何保证原子性呢？")],-1),m=n("p",null,"常见的做法就是加锁。",-1),b={href:"https://javabetter.cn/thread/synchronized-1.html",target:"_blank",rel:"noopener noreferrer"},f=n("code",null,"CAS",-1),_=n("code",null,"synchronized",-1),g={href:"https://javabetter.cn/thread/synchronized.html",target:"_blank",rel:"noopener noreferrer"},A=n("p",null,"如果不好理解，我们来举个生活中的例子：一个人进入厕所后首先把门锁上（获取锁），然后开始上厕所，这个时候有其他人来了就只能在外面等（阻塞），就算再急也没用。上完厕所完事后把门打开（解锁），其他人就可以进入了。",-1),C=n("figure",null,[n("img",{src:"https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/thread/cas-973e8804-c713-43f6-9a63-4b9f2be54f10.png",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),S=n("p",null,[n("code",null,"CAS"),a(" 是乐观锁，线程执行的时候不会加锁，它会假设此时没有冲突，然后完成某项操作；如果因为冲突失败了就重试，直到成功为止。")],-1),w=n("h2",{id:"乐观锁与悲观锁",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#乐观锁与悲观锁","aria-hidden":"true"},"#"),a(" 乐观锁与悲观锁")],-1),y={href:"https://javabetter.cn/thread/synchronized.html",target:"_blank",rel:"noopener noreferrer"},x=t('<h3 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁" aria-hidden="true">#</a> 悲观锁</h3><p>对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><h3 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁" aria-hidden="true">#</a> 乐观锁</h3><p>乐观锁，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 CAS 的技术来保证线程执行的安全性。</p><p>由于乐观锁假想操作中没有锁的存在，因此不太可能出现死锁的情况，换句话说，<strong>乐观锁天生免疫死锁</strong>。</p><ul><li>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；</li><li>悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</li></ul><h2 id="什么是-cas" tabindex="-1"><a class="header-anchor" href="#什么是-cas" aria-hidden="true">#</a> 什么是 CAS</h2><p>在 CAS 中，有这样三个值：</p><ul><li>V：要更新的变量(var)</li><li>E：预期值(expected)</li><li>N：新值(new)</li></ul><p>比较并交换的过程如下：</p><p>判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。</p><p>这里的<strong>预期值 E 本质上指的是“旧值”</strong>。</p><p>我们以一个简单的例子来解释这个过程：</p><ol><li>如果有一个多个线程共享的变量<code>i</code>原本等于 5，我现在在线程 A 中，想把它设置为新的值 6;</li><li>我们使用 CAS 来做这个事情；</li><li>首先我们用 i 去与 5 对比，发现它等于 5，说明没有被其它线程改过，那我就把它设置为新的值 6，此次 CAS 成功，<code>i</code>的值被设置成了 6；</li><li>如果不等于 5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为 2），那么我就什么也不做，此次 CAS 失败，<code>i</code>的值仍然为 2。</li></ol><p>在这个例子中，<code>i</code>就是 V，5 就是 E，6 就是 N。</p><p>那有没有可能我在判断了<code>i</code>为 5 之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p><p>不会的。因为 CAS 是一种原子操作，它是一种系统原语，是一条 CPU 的原子指令，从 CPU 层面已经保证它的原子性。</p><p><strong>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p><h2 id="cas-的原理" tabindex="-1"><a class="header-anchor" href="#cas-的原理" aria-hidden="true">#</a> CAS 的原理</h2>',19),j={href:"https://javabetter.cn/oo/native-method.html",target:"_blank",rel:"noopener noreferrer"},I=n("code",null,"Unsafe",-1),V={href:"https://javabetter.cn/thread/Unsafe.html",target:"_blank",rel:"noopener noreferrer"},J=n("code",null,"sun.misc",-1),P=n("code",null,"native",-1),R=t(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token class-name">Object</span> expected<span class="token punctuation">,</span> <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">int</span> expected<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">long</span> expected<span class="token punctuation">,</span><span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Unsafe 对 CAS 的实现是通过 C++ 实现的，它的具体实现和操作系统、CPU 都有关系。</p><p>Linux 的 X86 下主要是通过<code>cmpxchgl</code>这个指令在 CPU 上完成 CAS 操作的，但在多处理器情况下，必须使用<code>lock</code>指令加锁来完成。当然，不同的操作系统和处理器在实现方式上肯定会有所不同。</p><blockquote><p>CMPXCHG是“Compare and Exchange”的缩写，它是一种原子指令，用于在多核/多线程环境中安全地修改共享数据。CMPXCHG在很多现代微处理器体系结构中都有，例如Intel x86/x64体系。对于32位操作数，这个指令通常写作CMPXCHG，而在64位操作数中，它被称为CMPXCHG8B或CMPXCHG16B。</p></blockquote>`,4),U=n("code",null,"park",-1),B=n("code",null,"unpark",-1),M={href:"https://javabetter.cn/thread/LockSupport.html",target:"_blank",rel:"noopener noreferrer"},z={href:"https://javabetter.cn/basic-extra-meal/fanshe.html",target:"_blank",rel:"noopener noreferrer"},E=n("code",null,"allocateInstance()",-1),O=n("h2",{id:"cas-如何实现原子操作",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#cas-如何实现原子操作","aria-hidden":"true"},"#"),a(" CAS 如何实现原子操作？")],-1),D=n("p",null,"上面介绍了 Unsafe 类的几个支持 CAS 的方法。那 Java 具体是如何通过这几个方法来实现原子操作的呢？",-1),H=n("p",null,[a("JDK 提供了一些用于原子操作的类，在"),n("code",null,"java.util.concurrent.atomic"),a("包下面。在 JDK 8 中，有以下这些类：")],-1),N=n("figure",null,[n("img",{src:"https://cdn.tobebetterjavaer.com/stutymore/cas-20230731195315.png",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),K={href:"https://javabetter.cn/thread/atomic.html",target:"_blank",rel:"noopener noreferrer"},L=t(`<ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新字段（属性）</li></ul><p>这里我们以<code>AtomicInteger</code>类的<code>getAndAdd(int delta)</code>方法为例，来看看 Java 是如何实现原子操作的。</p><p>先来看 getAndAdd 方法的源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 unsafe 其实就是一个<code>Unsafe</code>对象：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// setup to use Unsafe.compareAndSwapInt for updates</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，<code>AtomicInteger</code>类的<code>getAndAdd()</code>方法是通过调用<code>Unsafe</code>类的方法实现的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> var5<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们详细分析下这段代码，先看参数：</p><ul><li>Object var1，这个参数代表你想要进行操作的对象。</li><li>long var2，这个参数是你想要操作的 var1 对象中的某个字段的偏移量。这个偏移量可以通过 Unsafe 类的 objectFieldOffset 方法获得。</li><li>int var4，这个参数是你想要增加的值。</li></ul><p>再来看方法执行的过程：</p>`,11),G=n("code",null,"this.getIntVolatile(var1, var2)",-1),X={href:"https://javabetter.cn/thread/jmm.html",target:"_blank",rel:"noopener noreferrer"},q=n("li",null,[a("然后，执行"),n("code",null,"compareAndSwapInt(var1, var2, var5, var5 + var4)"),a("进行 CAS 操作。如果对象 var1 在内存地址 var2 处的值等于预期值 var5，则将该位置的值更新为 var5 + var4，并返回 true；否则，不做任何操作并返回 false。")],-1),T=n("li",null,"如果 CAS 操作成功，说明我们成功地将 var1 对象的 var2 偏移量处的字段的值更新为 var5 + var4，并且这个更新操作是原子性的，因此我们跳出循环并返回原来的值 var5。",-1),F=n("li",null,"如果 CAS 操作失败，说明在我们尝试更新值的时候，有其他线程修改了该字段的值，所以我们继续循环，重新获取该字段的值，然后再次尝试进行 CAS 操作。",-1),Q=t(`<p>这里使用的是<strong>do-while 循环</strong>。这种循环不多见，它的目的是<strong>保证循环体内的语句至少会被执行一遍</strong>。这样才能保证 return 的值是我们期望的值。</p><p>JDK 9 及其以后版本中，getAndAddInt 方法和 JDK 8 中的实现有所不同，我们就拿 JDK 11 的源码来做一个对比吧：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@HotSpotIntrinsicCandidate</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> v<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        v <span class="token operator">=</span> <span class="token function">getIntVolatile</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">weakCompareAndSetInt</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v <span class="token operator">+</span> delta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法上面增加了 <code>@HotSpotIntrinsicCandidate</code> 注解。这个注解允许 HotSpot VM 自己来写汇编或 IR 编译器来实现该方法以提供更加的性能。</p><blockquote><p>IR（Intermediate Representation）是一种用于帮助优化编译器的中间代码表示方法。编译器通常将源代码首先转化为 IR，然后对 IR 进行各种优化，最后将优化后的 IR 转化为目标代码。在 JVM（Java Virtual Machine）中，JIT（Just-In-Time）编译器将 Java 字节码（即.class 文件的内容）转化为 IR，然后对 IR 进行优化，最后将 IR 编译为机器码。这个过程在 Java 程序运行时进行，因此被称为“即时编译”。JVM 中的 C1 和 C2 编译器就是 IR 编译器。C1 编译器在编译时进行一些简单的优化，然后快速地将 IR 编译为机器码。C2 编译器在编译时进行更深入的优化，以获得更高的执行效率，但编译的时间也相对更长。</p></blockquote><p>也就是说，虽然表面上看到的是 weakCompareAndSet 和 compareAndSet，但是不排除 HotSpot VM 会手动来实现 weakCompareAndSet 真正功能的可能性。</p><p>简单来说，<code>weakCompareAndSet</code> 操作仅保留了<code>volatile</code> 自身变量的特性，而除去了 happens-before 规则带来的内存语义。换句话说，<code>weakCompareAndSet</code><strong>无法保证处理操作目标的 volatile 变量外的其他变量的执行顺序（编译器和处理器为了优化程序性能而对指令序列进行重新排序），同时也无法保证这些变量的可见性。</strong> 但这在一定程度上可以提高性能。</p><p>再回到循环条件上来，可以看到它是在不断尝试去用 CAS 更新。如果更新失败，就继续重试。</p><p>为什么要把获取“旧值”v 的操作放到循环体内呢？</p><p>这也好理解。前面我们说了，CAS 如果旧值 V 不等于预期值 E，就会更新失败。说明旧的值发生了变化。那我们当然需要返回的是被其他线程改变之后的旧值了，因此放在了 do 循环体内。</p><h2 id="cas-的三大问题" tabindex="-1"><a class="header-anchor" href="#cas-的三大问题" aria-hidden="true">#</a> CAS 的三大问题</h2><p>尽管 CAS 提供了一种有效的同步手段，但也存在一些问题，主要有以下三个：ABA 问题、长时间自旋、多个共享变量的原子操作。</p><h3 id="aba-问题" tabindex="-1"><a class="header-anchor" href="#aba-问题" aria-hidden="true">#</a> ABA 问题</h3><p>所谓的 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。</p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类<code>AtomicStampedReference</code>类来解决 ABA 问题。</p><p>这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用 CAS 设置为新的值和标志。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token class-name">V</span>   expectedReference<span class="token punctuation">,</span>
                              <span class="token class-name">V</span>   newReference<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> expectedStamp<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> newStamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> current <span class="token operator">=</span> pair<span class="token punctuation">;</span>
    <span class="token keyword">return</span>
        expectedReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span>
        expectedStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>newReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span>
          newStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp<span class="token punctuation">)</span> <span class="token operator">||</span>
          <span class="token function">casPair</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>newReference<span class="token punctuation">,</span> newStamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先来看参数：</p><ul><li>expectedReference：预期引用，也就是你认为原本应该在那个位置的引用。</li><li>newReference：新引用，如果预期引用正确，将被设置到该位置的新引用。</li><li>expectedStamp：预期标记，这是你认为原本应该在那个位置的标记。</li><li>newStamp：新标记，如果预期标记正确，将被设置到该位置的新标记。</li></ul><p>执行流程：</p><p>①、<code>Pair&lt;V&gt; current = pair;</code> 这行代码获取当前的 pair 对象，其中包含了引用和标记。</p><p>②、接下来的 return 语句做了几个检查：</p><ul><li><code>expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp</code>：首先检查当前的引用和标记是否和预期的引用和标记相同。如果二者中有任何一个不同，这个方法就会返回 false。</li><li>如果上述检查通过，也就是说当前的引用和标记与预期的相同，那么接下来就会检查新的引用和标记是否也与当前的相同。如果相同，那么实际上没有必要做任何改变，这个方法就会返回 true。</li><li>如果新的引用或者标记与当前的不同，那么就会调用 casPair 方法来尝试更新 pair 对象。casPair 方法会尝试用 newReference 和 newStamp 创建的新的 Pair 对象替换当前的 pair 对象。如果替换成功，casPair 方法会返回 true；如果替换失败（也就是说在尝试替换的过程中，pair 对象已经被其他线程改变了），casPair 方法会返回 false。</li></ul><h3 id="长时间自旋" tabindex="-1"><a class="header-anchor" href="#长时间自旋" aria-hidden="true">#</a> 长时间自旋</h3><p>CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源。</p><p>解决思路是让 JVM 支持处理器提供的<strong>pause 指令</strong>。</p><p>pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率降低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。</p><h3 id="多个共享变量的原子操作" tabindex="-1"><a class="header-anchor" href="#多个共享变量的原子操作" aria-hidden="true">#</a> 多个共享变量的原子操作</h3><p>当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性，这时通常有两种做法：</p><ol><li>使用<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</li><li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li></ol><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>CAS（Compare-and-Swap）是一种被广泛应用在并发控制中的算法，它是一种乐观锁的实现方式。CAS 全称为“比较并交换”，是一种无锁的原子操作。</p><p>CAS 的全称是：比较并交换（Compare And Swap）。在 CAS 中，有这样三个值：</p><ul><li>V：要更新的变量(var)</li><li>E：预期值(expected)</li><li>N：新值(new)</li></ul><p>比较并交换的过程如下：</p><p>判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。</p><p>这里的<strong>预期值 E 本质上指的是“旧值”</strong>。</p><p>CAS 虽好，但也有一些问题，比如说 ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作等。在开发中，我们要根据实际情况来选择使用 CAS 还是使用锁。</p>`,38),W={href:"http://concurrent.redspider.group/",target:"_blank",rel:"noopener noreferrer"},Y=n("hr",null,null,-1),Z={href:"https://github.com/itwanger/toBeBetterJavaer",target:"_blank",rel:"noopener noreferrer"},$={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},nn={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},an={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},sn={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},en=n("figure",null,[n("img",{src:"https://cdn.tobebetterjavaer.com/stutymore/wangzhe-thread-20230904125125.png",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1);function tn(on,pn){const s=p("ExternalLinkIcon");return c(),l("div",null,[i,d,n("p",null,[a("在并发编程中，我们都知道"),u,a("操作是非线程安全的，这是因为 "),k,a("操作不是原子操作，我们之前在讲"),n("a",h,[a("多线程带来了什么问题"),e(s)]),a("中有讲到，大家应该还记得吧？")]),v,m,n("p",null,[a("在 Java 中，我们可以使用 "),n("a",b,[a("synchronized"),e(s)]),a("关键字和 "),f,a(" 来实现加锁效果。")]),n("p",null,[_,a(" 是悲观锁，尽管随着 JDK 版本的升级，synchronized 关键字已经“轻量级”了很多（"),n("a",g,[a("前面有细讲，戳链接回顾"),e(s)]),a("），但依然是悲观锁，线程开始执行第一步就要获取锁，一旦获得锁，其他的线程进入后就会阻塞并等待锁。")]),A,C,S,w,n("p",null,[a("锁可以从不同的角度来分类。比如我们在前面讲 "),n("a",y,[a("synchronized 四种锁状态"),e(s)]),a("的时候，提到过偏向锁、轻量级锁、重量级锁，对吧？乐观锁和悲观锁也是一种分类方式。")]),x,n("p",null,[a("前面提到，CAS 是一种原子操作。那么 Java 是怎样来使用 CAS 的呢？我们知道，在 Java 中，如果一个"),n("a",j,[a("方法是 native 的"),e(s)]),a("，那 Java 就不负责具体实现它，而是交给底层的 JVM 使用 C 语言 或者 C++ 去实现。")]),n("p",null,[a("在 Java 中，有一个"),I,a("类（"),n("a",V,[a("后面会细讲，戳链接直达"),e(s)]),a("），它在"),J,a("包中。它里面都是一些"),P,a("方法，其中就有几个是关于 CAS 的：")]),R,n("p",null,[a("除了上面提到的方法，Unsafe 里面还有其它的方法。比如支持线程挂起和恢复的"),U,a("和"),B,a(" 方法， "),n("a",M,[a("LockSupport 类（后面会讲）"),e(s)]),a("底层就调用了这两个方法。还有支持"),n("a",z,[a("反射"),e(s)]),a("操作的"),E,a("方法。")]),O,D,H,N,n("p",null,[a("从名字就可以看出来这些类大概的用途（"),n("a",K,[a("原子类后面会细讲，戳链接直达"),e(s)]),a("）：")]),L,n("ul",null,[n("li",null,[a("首先，在 do while 循环开始，通过"),G,a("获取当前对象指定字段的值，将其存入临时变量 var5 中。这里的 getIntVolatile 方法能保证读操作的可见性，即读取的结果是最新的写入结果，不会因为 JVM 的优化策略（如"),n("a",X,[a("指令重排序"),e(s)]),a("）或者 CPU 的缓存导致读取到过期的数据。")]),q,T,F]),Q,n("blockquote",null,[n("p",null,[a("编辑：沉默王二，编辑前的内容来源于朋友开源的这个仓库："),n("a",W,[a("深入浅出 Java 多线程"),e(s)]),a("，强烈推荐。")])]),Y,n("p",null,[a("GitHub 上标星 10000+ 的开源知识库《"),n("a",Z,[a("二哥的 Java 进阶之路"),e(s)]),a("》第二份 PDF 《"),n("a",$,[a("并发编程小册"),e(s)]),a("》终于来了！包括线程的基本概念和使用方法、Java的内存模型、sychronized、volatile、CAS、AQS、ReentrantLock、线程池、并发容器、ThreadLocal、生产者消费者模型等面试和开发必须掌握的内容，共计 15 万余字，200+张手绘图，可以说是通俗易懂、风趣幽默……详情戳："),n("a",nn,[a("太赞了，二哥的并发编程进阶之路.pdf"),e(s)])]),n("p",null,[n("a",an,[a("加入二哥的编程星球"),e(s)]),a("，在星球的第二个置顶帖「"),n("a",sn,[a("知识图谱"),e(s)]),a("」里就可以获取 PDF 版本。")]),en])}const rn=o(r,[["render",tn],["__file","cas.html.vue"]]);export{rn as default};
